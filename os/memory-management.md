

> 주소 바인딩



메모리는 주소를 통해 접근하는 매체



### 논리적, 물리적 주소



+ 논리적 주소 (*Logical address* / *Virtual address*  )
  +  프로세스마다 독립적으로 가지는 주소공간
  +  각 프로세스마다 0번지부터 시작
  +  CPU가 보는 주소는 논리적 주소
     
     
+ 물리적 주소 (*Physical address*)
  + 메모리에 실제 올라가는 위치



+ 주소 바인딩: 주소를 결정하는 것

  + Symbolic Address ---> Logical Address ---(<u>이 시점이 언제인가?</u>)---> Physical address

  + 심볼릭 어드레스

    + 프로그래머는 심볼로 된 주소 사용

    + 이게 컴파일 되면 숫자로 된 로지컬 어드레스가 만들어진다. 

      

### 주소 바인딩

CPU가 바라보는 주소는 logical address다. 

주소를 바인딩하는 방식은 프로그램이 적재되는 물리적 메모리의 주소가 결정되는 시기에 따라 세 가지로 분류될 수 있다. 



+ 컴파일 타임 바인딩 (Compile time binding)
  + **프로그램을 컴파일할때** 물리적 메모리의 주소가 결정됨
  + 컴파일 이후 프로그램이 올라가 있는 물리적 메모리의 위치를 변경하고자한다면 다시 컴파일 해야한다.
  + 현대의 시분할 컴퓨팅 환경에선 잘 사용하지 않는다. 

+ 로드 타임 바인딩 (Load time binding)
  + **프로그램의 실행이 시작될때** 프로그램의 물리적 메모리 주소가 결정됨
  + 컴파일러가 relocatable code를 생성한 경우 가능하다. 

+ 실행 타임 바인딩 (Execution time binding / Run time binding)
  + 프로그램 실행 이우헤도 프로세스의 메모리상 위치를 옮길 수 있다.
  + CPU가 주소를 참조할때마다 해당 데이터가 물리적 메모리의 어느 위치에 존재하는지 address mapping table을 통해 binding을 점검해야한다.
  + **MMU** 라는 하드웨어적인 지원이 필요하다. 



<img width="926" alt="스크린샷 2021-04-27 오후 8 14 40" src="https://user-images.githubusercontent.com/31922389/116249190-848ad480-a7a7-11eb-9dbf-a3c70e7b8175.png">



### MMU (Memory Management Unit)

+ 논리적 주소를 물리적 주소로 매핑해주는 하드웨어적 장치
+ MMU 기법은 CPU가 특정 프로세스의 논리적 주소를 참조하려할때 그 주소값에 *기준 레지스터*의 값을 더해 물리적 주소값을 얻어낸다. 
  + 기준 레지스터
    + 재배치 레지스터(relocation register) 라고도 한다
    + 해당 프로세스의 물리적 메모리 시작주소를 가지고 있다. 
+ MMU 기법은 프로그램의 주소공간이 물리적 메모리의 한 장소에 연속적으로 적재되는 것으로 가정한다. 
  + 그러므로 해당 프로그램이 적재되는 물리적 메모리상의 시작 주소만 알면 주소 변환을 쉽게 할 수 있다.
+ MMU 기법에서 사용자 프로그램이나 CPU는 <u>논리적 주소만 다룬다.</u> 

